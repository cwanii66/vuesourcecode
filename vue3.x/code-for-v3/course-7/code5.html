<body></body>

<script>
  const TextModes = {
    DATA: "DATA",
    RCDATA: "RCDATA",
    RAWTEXT: "RAWTEXT",
    CDATA: "CDATA",
  };

  function parse(str) {
    const context = {
      source: str,
      mode: TextModes.DATA,
      advanceBy(num) {
        context.source = context.source.slice(num);
      },
      advanceSpaces() {
        const match = /^[\t\r\n\f ]+/.exec(context.source);
        if (match) {
          context.advanceBy(match[0].length);
        }
      },
    };
    // arguments[1] -> ancestors stack
    const nodes = parseChildren(context, []);
    return {
      type: "Root",
      children: nodes,
    };
  }

  function parseChildren(context, ancestors) {
    let nodes = [];
    const { mode, source } = context;

    while (!isEnd(context, ancestors)) {
      let node;
      if (mode === TextModes.DATA || mode === TextModes.RCDATA) {
        if (mode === TextModes.DATA && source[0] === "<") {
          if (source[1] === "!") {
            if (source.startsWith("<!--")) {
              node = parseComment(context);
            } else if (source.startsWith("<![CDATA[")) {
              node = parseCDATA(context, ancestors);
            }
          } else if (source[1] === "/") {
            // need to throw an error
            // console.error('无效的结束标签...');
            // continue;
          } else if (/[a-z]/i.test(source[1])) {
            node = parseElement(context, ancestors); // entry of recursive decent
          }
        } else if (source.startsWith("{ {")) {
          node = parseInterpolation(context);
        }
      }

      if (!node) {
        node = parseText(context);
      }

      nodes.push(node);
    }

    return nodes;
  }

  function parseElement(context, ancestors) {
    const element = parseTag(context)
    if (element.isSelfClosing) return element

    ancestors.push(element)
    element.children = parseChildren(context, ancestors)
    ancestors.pop()
    
    if (context.source.startsWith(`${element.tag}`)) {
      parseTag(context, 'end')
    } else {
      console.error(`${element.tag}标签缺少闭合标签`)
    }
    return element
  }
  function parseInterpolation(context) {}
  function parseCDATA(context, ancestors) {}
  function parseComment(context) {}
  function parseText(context) {}

  function isEnd(context, ancestors) {
    if (!context.source) return true;

    const parent = ancestors[ancestors.length - 1];
    for (let i = ancestors.length - 1; i >= 0; --i) {
      if (parent && context.source.startsWith(`</${ancestors[i].tag}`)) {
        return true;
      }
    }
  }
</script>

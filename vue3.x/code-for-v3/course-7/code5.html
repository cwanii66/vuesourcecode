<body></body>

<script>
  const TextModes = {
    DATA: "DATA",
    RCDATA: "RCDATA",
    RAWTEXT: "RAWTEXT",
    CDATA: "CDATA",
  };

  function parse(str) {
    const context = {
      source: str,
      mode: TextModes.DATA,
      advanceBy(num) {
        // advanceBy 用来消费指定数量的字符，它接收一个数字作为参数
        context.source = context.source.slice(num);
      },
      advanceSpaces() {
        // 消费空白字符
        const match = /^[\t\r\n\f ]+/.exec(context.source);
        if (match) {
          context.advanceBy(match[0].length);
        }
      },
    };
    // arguments[1] -> ancestors stack
    const nodes = parseChildren(context, []);
    return {
      type: "Root",
      children: nodes,
    };
  }

  function parseChildren(context, ancestors) {
    let nodes = [];
    const { mode, source } = context;

    while (!isEnd(context, ancestors)) {
      let node;
      if (mode === TextModes.DATA || mode === TextModes.RCDATA) {
        if (mode === TextModes.DATA && source[0] === "<") {
          if (source[1] === "!") {
            if (source.startsWith("<!--")) {
              node = parseComment(context);
            } else if (source.startsWith("<![CDATA[")) {
              node = parseCDATA(context, ancestors);
            }
          } else if (source[1] === "/") {
            // need to throw an error
            // console.error('无效的结束标签...');
            // continue;
          } else if (/[a-z]/i.test(source[1])) {
            node = parseElement(context, ancestors); // entry of recursive decent
          }
        } else if (source.startsWith("{ {")) {
          node = parseInterpolation(context);
        }
      }

      if (!node) {
        node = parseText(context);
      }

      nodes.push(node);
    }

    return nodes;
  }

  function parseElement(context, ancestors) {
    const element = parseTag(context);
    if (element.isSelfClosing) return element;

    ancestors.push(element);
    // 切换到正确的文本模式
    if (element.tag === 'textarea' || element.tag === 'title') {
      context.mode = TextModes.RCDATA
    } else if (/style|xmp|iframe|noembed|noframes|noscript/.test(element.tag)) {
      context.mode = TextModes.RAWTEXT
    } else {
      context.mode = TextModes.DATA
    }
    element.children = parseChildren(context, ancestors);
    ancestors.pop();

    if (context.source.startsWith(`${element.tag}`)) {
      parseTag(context, "end");
    } else {
      console.error(`${element.tag}标签缺少闭合标签`);
    }
    return element;
  }
  function parseTag(context, type = "start") {
    const { advanceBy, advanceSpaces } = context;
    const match =
      type === "start"
        ? /^<([a-z][^\t\r\n\f />]*)/i.exec(context.source)
        : /^<\/([a-z][^\t\r\n\f />]*)/i.exec(context.source);
    const tag = match[1]

    advanceBy(match[0].length)
    advanceSpaces()

    const props = parseAttributes(context)

    const isSelfClosing = context.source.startsWith('/>')
    advanceBy(isSelfClosing ? 2 : 1)

    return {
      type: 'Element',
      tag,
      props,
      children: [],
      isSelfClosing
    }
  }
  function parseAttributes(context) {
    const { advanceBy, advanceSpaces } = context
    const props = []

    while(
      !context.source.startsWith('>') &&
      !context.source.startsWith('/>')
    ) {
      const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source)
      const name = match[0]

      advanceBy(name.length)
      advanceSpaces()
      advanceBy(1) // =
      advanceSpaces()

      let value = ''

      const quote = context.source[0]
      const isQuote = (quote === '"' || quote === "'")
      
      if (isQuote) {
        advanceBy(1) // "
        const endQuoteIndex = context.source.indexOf(quote)
        if (endQuoteIndex > -1) {
          value = context.source.slice(0, endQuoteIndex)
          advanceBy(1)
        } else {
          console.error('缺少引号')
        }
      } else {
        const match = /^[^\t\n\r\f >]+]/.exec(context.source)
        value = match[0]
        advanceBy(value.length)
      }
      advanceSpaces()

      props.push({
        type: 'Attribute',
        name,
        value
      })
    }
    return props
  }
  function parseInterpolation(context) {}
  function parseCDATA(context, ancestors) {}
  function parseComment(context) {}
  function parseText(context) {
    const endIndex = context.source.length // default: rest of the entire template
    const ltIndex = context.source.indexOf('<')
    const delimiterIndex = context.source.indexOf('{ {')

    // {{}}  &   <  ==> two satuations
    if (ltIndex > -1 && ltIndex < endIndex) {
      endIndex = ltIndex
    }
    if (delimiterIndex > -1 && delimiterIndex < endIndex) {
      endIndex = delimiterIndex
    }
    const content = context.source.slice(0, endIndex)
    context.advanceBy(content.length)

    return {
      type: 'text',
      content: decodeHtml(content)
    }
  }

  function isEnd(context, ancestors) {
    if (!context.source) return true;

    const parent = ancestors[ancestors.length - 1];
    for (let i = ancestors.length - 1; i >= 0; --i) {
      if (parent && context.source.startsWith(`</${ancestors[i].tag}`)) {
        return true;
      }
    }
  }

  const namedCharacterReferences = {
    "gt": ">",
    "gt;": ">",
    "lt": "<",
    "lt;": "<",
    "ltcc": "⪦"
  }
  
  function decodeHtml(rawText, asAttr = false) {
    let offset = 0
    const end = rawText.length
    let decodedText = '' // output
    let maxCRNameLength = 0 // max length of character reference

    function advance(length) {
      offset += length
      rawText = rawText.slice(length)
    }

    while (offset < end) {
      // 1. &    named reference
      // 2. &#   decimal
      // 3. &#x  hexa-decimal
      const head = /&(?:#x?)?/i.exec(rawText)
      if (!head) {
        const remaining = end - offset
        decodedText += rawText.slice(0, remaining)
        advance(remaining)
        break
      }
      decodedText += rawText.slice(0, head.index)
      advance(head.index)

      if (head[0] === '&') {
        let name = ''
        let value

        if (/[0-9a-z]/i.test(rawText[1])) {
          if (!maxCRNameLength) {
            maxCRNameLength = Object.keys(namedCharacterReferences).reduce(
              (max, name) => Math.max(max, name.length), 0
            )
          }
          for (let l = maxCRNameLength; !value && l > 0; --l) {
            name = rawText.substr(1, l)
            value = (namedCharacterReferences)[name]
          }
          if (value) {
            const semi = name.endsWith(';')
            if (
              asAttr &&
              !semi &&
              /[=a-z0-9]/i.test(rawText[name.length + 1] || '')
            ) {
              decodedText += `&${name}`
              advance(1 + name.length)
            } else {
              decodedText += value
              advance(1 + name.length)
            }
          } else {
            decodedText += `&${name}`
            advance(1 + name.length)
            console.warn('may decode failed, please checkout the reference table')
          }
        } else {
          decodedText += '&'
          advance(1)
        }
      }
    }

    return decodedText
  }

</script>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>reactivity</title>
</head>
<body>
    
<script src="./index.js"></script>
<script>
(function() {
    function reactive(obj) {
        return new Proxy(obj, {
            get(target, propKey, receiver) {
                track(target, propKey); // track the read operation
                return target[propKey];
            },
            set(target, key, value) {
                target[key] = value;
                trigger(target, key); // trigger the subscribers of the dependencies
            }
        })
    }
    function ref(value) {
        const refObj = {
            get value() {
                track(refObj, 'value');
                return value;
            },
            set value(newValue) {
                value = newValue;
                trigger(refObj, 'value');
            }
        }
        return refObj;
    }
    /*
    * 在 track() 内部，我们会检查当前是否有正在运行的副作用。
    * 如果有，我们会查找到一个存储了所有追踪了该属性的订阅者的 Set，
    * 然后将当前这个副作用作为新订阅者添加到该 Set 中。
    */
    let activeEffect;
    function track(obj, key) {
        if (activeEffect) {
            const effects = getSubscribersForProperty(obj, key);
            effects.add(activeEffect);
        }
    }
    // 在 trigger() 之中，我们会再查找到该属性的所有订阅副作用。但这一次我们需要执行它们：
    function trigger(obj, key) {
        const effects = getSubscribersForProperty(obj, key);
        effects.forEach(effect => effect());
    }
    function whenDepsChange(update) {
        const effect = () => {
            activeEffect = effect;
            update();
            activeEffect = null;
        }
        effect();
    }
    // this is why we call ref/reactive is the reactive api
    // because we read the state object, we track them as dependencies, and when change state, we trigger the sideEffects
    // WeakMap <target, Map<key, Set<effect>>>
})()
</script>
</body>
</html>